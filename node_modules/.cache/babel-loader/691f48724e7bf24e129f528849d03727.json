{"ast":null,"code":"/*! npm.im/iphone-inline-video 2.2.2 */\nimport { frameIntervalometer } from 'intervalometer';\nfunction preventEvent(element, eventName, test) {\n  function handler(e) {\n    if (!test || test(element, eventName)) {\n      e.stopImmediatePropagation();\n      // // console.log(eventName, 'prevented on', element);\n    }\n  }\n\n  element.addEventListener(eventName, handler);\n\n  // Return handler to allow to disable the prevention. Usage:\n  // const preventionHandler = preventEvent(el, 'click');\n  // el.removeEventHandler('click', preventionHandler);\n  return handler;\n}\nfunction proxyProperty(object, propertyName, sourceObject, copyFirst) {\n  function get() {\n    return sourceObject[propertyName];\n  }\n  function set(value) {\n    sourceObject[propertyName] = value;\n  }\n  if (copyFirst) {\n    set(object[propertyName]);\n  }\n  Object.defineProperty(object, propertyName, {\n    get: get,\n    set: set\n  });\n}\nfunction proxyEvent(object, eventName, sourceObject) {\n  sourceObject.addEventListener(eventName, function () {\n    return object.dispatchEvent(new Event(eventName));\n  });\n}\nfunction dispatchEventAsync(element, type) {\n  Promise.resolve().then(function () {\n    element.dispatchEvent(new Event(type));\n  });\n}\nvar iOS8or9 = typeof document === 'object' && 'object-fit' in document.head.style && !matchMedia('(-webkit-video-playable-inline)').matches;\nvar IIV = 'bfred-it:iphone-inline-video';\nvar IIVEvent = 'bfred-it:iphone-inline-video:event';\nvar IIVPlay = 'bfred-it:iphone-inline-video:nativeplay';\nvar IIVPause = 'bfred-it:iphone-inline-video:nativepause';\n\n/**\n * UTILS\n */\n\nfunction getAudioFromVideo(video) {\n  var audio = new Audio();\n  proxyEvent(video, 'play', audio);\n  proxyEvent(video, 'playing', audio);\n  proxyEvent(video, 'pause', audio);\n  audio.crossOrigin = video.crossOrigin;\n\n  // 'data:' causes audio.networkState > 0\n  // which then allows to keep <audio> in a resumable playing state\n  // i.e. once you set a real src it will keep playing if it was if .play() was called\n  audio.src = video.src || video.currentSrc || 'data:';\n\n  // // if (audio.src === 'data:') {\n  //   TODO: wait for video to be selected\n  // // }\n  return audio;\n}\nvar lastRequests = [];\nvar requestIndex = 0;\nvar lastTimeupdateEvent;\nfunction setTime(video, time, rememberOnly) {\n  // Allow one timeupdate event every 200+ ms\n  if ((lastTimeupdateEvent || 0) + 200 < Date.now()) {\n    video[IIVEvent] = true;\n    lastTimeupdateEvent = Date.now();\n  }\n  if (!rememberOnly) {\n    video.currentTime = time;\n  }\n  lastRequests[++requestIndex % 3] = time * 100 | 0 / 100;\n}\nfunction isPlayerEnded(player) {\n  return player.driver.currentTime >= player.video.duration;\n}\nfunction update(timeDiff) {\n  var player = this;\n  // // console.log('update', player.video.readyState, player.video.networkState, player.driver.readyState, player.driver.networkState, player.driver.paused);\n  if (player.video.readyState >= player.video.HAVE_FUTURE_DATA) {\n    if (!player.hasAudio) {\n      player.driver.currentTime = player.video.currentTime + timeDiff * player.video.playbackRate / 1000;\n      if (player.video.loop && isPlayerEnded(player)) {\n        player.driver.currentTime = 0;\n      }\n    }\n    setTime(player.video, player.driver.currentTime);\n  } else if (player.video.networkState === player.video.NETWORK_IDLE && player.video.buffered.length === 0) {\n    // This should happen when the source is available but:\n    // - it's potentially playing (.paused === false)\n    // - it's not ready to play\n    // - it's not loading\n    // If it hasAudio, that will be loaded in the 'emptied' handler below\n    player.video.load();\n    // // console.log('Will load');\n  }\n\n  // // console.assert(player.video.currentTime === player.driver.currentTime, 'Video not updating!');\n\n  if (player.video.ended) {\n    delete player.video[IIVEvent]; // Allow timeupdate event\n    player.video.pause(true);\n  }\n}\n\n/**\n * METHODS\n */\n\nfunction play() {\n  // // console.log('play');\n  var video = this;\n  var player = video[IIV];\n\n  // If it's fullscreen, use the native player\n  if (video.webkitDisplayingFullscreen) {\n    video[IIVPlay]();\n    return;\n  }\n  if (player.driver.src !== 'data:' && player.driver.src !== video.src) {\n    // // console.log('src changed on play', video.src);\n    setTime(video, 0, true);\n    player.driver.src = video.src;\n  }\n  if (!video.paused) {\n    return;\n  }\n  player.paused = false;\n  if (video.buffered.length === 0) {\n    // .load() causes the emptied event\n    // the alternative is .play()+.pause() but that triggers play/pause events, even worse\n    // possibly the alternative is preventing this event only once\n    video.load();\n  }\n  player.driver.play();\n  player.updater.start();\n  if (!player.hasAudio) {\n    dispatchEventAsync(video, 'play');\n    if (player.video.readyState >= player.video.HAVE_ENOUGH_DATA) {\n      // // console.log('onplay');\n      dispatchEventAsync(video, 'playing');\n    }\n  }\n}\nfunction pause(forceEvents) {\n  // // console.log('pause');\n  var video = this;\n  var player = video[IIV];\n  player.driver.pause();\n  player.updater.stop();\n\n  // If it's fullscreen, the developer the native player.pause()\n  // This is at the end of pause() because it also\n  // needs to make sure that the simulation is paused\n  if (video.webkitDisplayingFullscreen) {\n    video[IIVPause]();\n  }\n  if (player.paused && !forceEvents) {\n    return;\n  }\n  player.paused = true;\n  if (!player.hasAudio) {\n    dispatchEventAsync(video, 'pause');\n  }\n\n  // Handle the 'ended' event only if it's not fullscreen\n  if (video.ended && !video.webkitDisplayingFullscreen) {\n    video[IIVEvent] = true;\n    dispatchEventAsync(video, 'ended');\n  }\n}\n\n/**\n * SETUP\n */\n\nfunction addPlayer(video, hasAudio) {\n  var player = {};\n  video[IIV] = player;\n  player.paused = true; // Track whether 'pause' events have been fired\n  player.hasAudio = hasAudio;\n  player.video = video;\n  player.updater = frameIntervalometer(update.bind(player));\n  if (hasAudio) {\n    player.driver = getAudioFromVideo(video);\n  } else {\n    video.addEventListener('canplay', function () {\n      if (!video.paused) {\n        // // console.log('oncanplay');\n        dispatchEventAsync(video, 'playing');\n      }\n    });\n    player.driver = {\n      src: video.src || video.currentSrc || 'data:',\n      muted: true,\n      paused: true,\n      pause: function pause() {\n        player.driver.paused = true;\n      },\n      play: function play() {\n        player.driver.paused = false;\n        // Media automatically goes to 0 if .play() is called when it's done\n        if (isPlayerEnded(player)) {\n          setTime(video, 0);\n        }\n      },\n      get ended() {\n        return isPlayerEnded(player);\n      }\n    };\n  }\n\n  // .load() causes the emptied event\n  video.addEventListener('emptied', function () {\n    // // console.log('driver src is', player.driver.src);\n    var wasEmpty = !player.driver.src || player.driver.src === 'data:';\n    if (player.driver.src && player.driver.src !== video.src) {\n      // // console.log('src changed to', video.src);\n      setTime(video, 0, true);\n      player.driver.src = video.src;\n      // Playing videos will only keep playing if no src was present when .play()â€™ed\n      if (wasEmpty || !hasAudio && video.autoplay) {\n        player.driver.play();\n      } else {\n        player.updater.stop();\n      }\n    }\n  }, false);\n\n  // Stop programmatic player when OS takes over\n  video.addEventListener('webkitbeginfullscreen', function () {\n    if (!video.paused) {\n      // Make sure that the <audio> and the syncer/updater are stopped\n      video.pause();\n\n      // Play video natively\n      video[IIVPlay]();\n    } else if (hasAudio && player.driver.buffered.length === 0) {\n      // If the first play is native,\n      // the <audio> needs to be buffered manually\n      // so when the fullscreen ends, it can be set to the same current time\n      player.driver.load();\n    }\n  });\n  if (hasAudio) {\n    video.addEventListener('webkitendfullscreen', function () {\n      // Sync audio to new video position\n      player.driver.currentTime = video.currentTime;\n      // // console.assert(player.driver.currentTime === video.currentTime, 'Audio not synced');\n    });\n\n    // Allow seeking\n    video.addEventListener('seeking', function () {\n      if (lastRequests.indexOf(video.currentTime * 100 | 0 / 100) < 0) {\n        // // console.log('User-requested seeking');\n        player.driver.currentTime = video.currentTime;\n      }\n    });\n  }\n}\nfunction preventWithPropOrFullscreen(el) {\n  var isAllowed = el[IIVEvent];\n  delete el[IIVEvent];\n  return !el.webkitDisplayingFullscreen && !isAllowed;\n}\nfunction overloadAPI(video) {\n  var player = video[IIV];\n  video[IIVPlay] = video.play;\n  video[IIVPause] = video.pause;\n  video.play = play;\n  video.pause = pause;\n  proxyProperty(video, 'paused', player.driver);\n  proxyProperty(video, 'muted', player.driver, true);\n  proxyProperty(video, 'playbackRate', player.driver, true);\n  proxyProperty(video, 'ended', player.driver);\n  proxyProperty(video, 'loop', player.driver, true);\n\n  // IIV works by seeking 60 times per second.\n  // These events are now useless.\n  preventEvent(video, 'seeking', function (el) {\n    return !el.webkitDisplayingFullscreen;\n  });\n  preventEvent(video, 'seeked', function (el) {\n    return !el.webkitDisplayingFullscreen;\n  });\n\n  // Limit timeupdate events\n  preventEvent(video, 'timeupdate', preventWithPropOrFullscreen);\n\n  // Prevent occasional native ended events\n  preventEvent(video, 'ended', preventWithPropOrFullscreen);\n}\nfunction enableInlineVideo(video, opts) {\n  if (opts === void 0) opts = {};\n\n  // Stop if already enabled\n  if (video[IIV]) {\n    return;\n  }\n\n  // Allow the user to skip detection\n  if (!opts.everywhere) {\n    // Only iOS8 and 9 are supported\n    if (!iOS8or9) {\n      return;\n    }\n\n    // Stop if it's not an allowed device\n    if (!(opts.iPad || opts.ipad ? /iPhone|iPod|iPad/ : /iPhone|iPod/).test(navigator.userAgent)) {\n      return;\n    }\n  }\n\n  // Try to pause\n  video.pause();\n\n  // Prevent autoplay.\n  // An non-started autoplaying video can't be .pause()'d\n  var willAutoplay = video.autoplay;\n  video.autoplay = false;\n  addPlayer(video, !video.muted);\n  overloadAPI(video);\n  video.classList.add('IIV');\n\n  // Autoplay\n  if (video.muted && willAutoplay) {\n    video.play();\n    video.addEventListener('playing', function restoreAutoplay() {\n      video.autoplay = true;\n      video.removeEventListener('playing', restoreAutoplay);\n    });\n  }\n  if (!/iPhone|iPod|iPad/.test(navigator.platform)) {\n    console.warn('iphone-inline-video is not guaranteed to work in emulated environments');\n  }\n}\nexport default enableInlineVideo;","map":null,"metadata":{},"sourceType":"module"}